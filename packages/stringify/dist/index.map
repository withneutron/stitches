{
  "version": 3,
  "sources": ["../src/toCase.js", "../src/getResolvedSelectors.js", "../src/Array.js", "../src/index.js"],
  "sourcesContent": ["/** Returns the given value converted to kebab-case. */\nexport const toKebabCase = (/** @type {string} */ value) => (\n\t// ignore kebab-like values\n\tvalue.includes('-')\n\t\t? value\n\t// replace any upper-case letter with a dash and the lower-case variant\n\t: value.replace(/[A-Z]/g, (capital) => '-' + capital.toLowerCase())\n)\n\n/** Returns the given value converted to camel-case. */\nexport const toCamelCase = (/** @type {string} */ value) => (!/[A-Z]/.test(value) ? value.replace(/-[^]/g, (capital) => capital[1].toUpperCase()) : value)\n", "/** Returns selectors resolved from parent selectors and nested selectors. */\nexport const getResolvedSelectors = (\n\t/** @type {string[]} Parent selectors (e.g. `[\"a\", \"button\"]`). */\n\tparentSelectors,\n\t/** @type {string[]} Nested selectors (e.g. `[\"&:hover\", \"&:focus\"]`). */\n\tnestedSelectors,\n) => (\n\tparentSelectors.reduce(\n\t\t(resolvedSelectors, parentSelector) => {\n\t\t\tresolvedSelectors.push(\n\t\t\t\t...nestedSelectors.map(\n\t\t\t\t\t(selector) => (\n\t\t\t\t\t\tselector.includes('&') ? selector.replace(\n\t\t\t\t\t\t\t/&/g,\n\t\t\t\t\t\t\t/[ +>|~]/.test(parentSelector) && /&.*&/.test(selector)\n\t\t\t\t\t\t\t\t? `:is(${parentSelector})`\n\t\t\t\t\t\t\t: parentSelector\n\t\t\t\t\t\t) : parentSelector + ' ' + selector\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\n\t\t\treturn resolvedSelectors\n\t\t},\n\t\t[]\n\t)\n)\n", "export const { isArray } = Array\nexport const { from } = Array\n", "import { toKebabCase } from './toCase.js'\nimport { getResolvedSelectors } from './getResolvedSelectors.js'\nimport { isArray } from './Array.js'\n\nconst { prototype: { toString } } = Object\n\n/** Comma matcher outside rounded brackets. */\nconst comma = /\\s*,\\s*(?![^()]*\\))/\n\n/** Returns a string of CSS from an object of CSS. */\nexport const stringify = (\n\t/** Object representing the current CSS. */\n\tvalue,\n\t/** Replacer function. */\n\treplacer = undefined,\n) => {\n\t/** Set used to manage the opened and closed state of rules. */\n\tconst used = new WeakSet()\n\n\tconst parse = (style, selectors, conditions, prevName, prevData) => {\n\t\tlet cssText = ''\n\n\t\teach: for (const name in style) {\n\t\t\tconst isAtRuleLike = name.charCodeAt(0) === 64\n\n\t\t\tfor (const data of isAtRuleLike && isArray(style[name]) ? style[name] : [style[name]]) {\n\t\t\t\tif (replacer && (name !== prevName || data !== prevData)) {\n\t\t\t\t\tconst next = replacer(name, data, style)\n\n\t\t\t\t\tif (next !== null) {\n\t\t\t\t\t\tcssText += typeof next === 'object' && next ? parse(next, selectors, conditions, name, data) : next == null ? '' : next\n\n\t\t\t\t\t\tcontinue each\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst isObjectLike = typeof data === 'object' && data && data.toString === toString\n\n\t\t\t\tif (isObjectLike) {\n\t\t\t\t\tif (used.has(selectors)) {\n\t\t\t\t\t\tused.delete(selectors)\n\n\t\t\t\t\t\tcssText += '}'\n\t\t\t\t\t}\n\n\t\t\t\t\tconst usedName = Object(name)\n\n\t\t\t\t\tconst nextSelectors = isAtRuleLike ? selectors : selectors.length ? getResolvedSelectors(selectors, name.split(comma)) : name.split(comma)\n\n\t\t\t\t\tcssText += parse(data, nextSelectors, isAtRuleLike ? conditions.concat(usedName) : conditions)\n\n\t\t\t\t\tif (used.has(usedName)) {\n\t\t\t\t\t\tused.delete(usedName)\n\t\t\t\t\t\tcssText += '}'\n\t\t\t\t\t}\n\n\t\t\t\t\tif (used.has(nextSelectors)) {\n\t\t\t\t\t\tused.delete(nextSelectors)\n\t\t\t\t\t\tcssText += '}'\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (let i = 0; i < conditions.length; ++i) {\n\t\t\t\t\t\tif (!used.has(conditions[i])) {\n\t\t\t\t\t\t\tused.add(conditions[i])\n\n\t\t\t\t\t\t\tcssText += conditions[i] + '{'\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (selectors.length && !used.has(selectors)) {\n\t\t\t\t\t\tused.add(selectors)\n\n\t\t\t\t\t\tcssText += selectors + '{'\n\t\t\t\t\t}\n\n\t\t\t\t\tcssText += (isAtRuleLike ? name + ' ' : toKebabCase(name) + ':') + String(data) + ';'\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn cssText\n\t}\n\n\treturn parse(value, [], [])\n}\n"],
  "mappings": ";AACO,IAAM,cAAc,CAAuB,UAEjD,MAAM,SAAS,OACZ,QAED,MAAM,QAAQ,UAAU,CAAC,YAAY,MAAM,QAAQ;;;ACL/C,IAAM,uBAAuB,CAEnC,iBAEA,oBAEA,gBAAgB,OACf,CAAC,mBAAmB,mBAAmB;AACtC,oBAAkB,KACjB,GAAG,gBAAgB,IAClB,CAAC,aACA,SAAS,SAAS,OAAO,SAAS,QACjC,MACA,UAAU,KAAK,mBAAmB,OAAO,KAAK,YAC3C,OAAO,oBACR,kBACC,iBAAiB,MAAM;AAK9B,SAAO;AAAA,GAER;;;ACxBK,IAAM,EAAE,YAAY;;;ACI3B,IAAM,EAAE,WAAW,EAAE,eAAe;AAGpC,IAAM,QAAQ;AAGP,IAAM,YAAY,CAExB,OAEA,WAAW,WACP;AAEJ,QAAM,OAAO,IAAI;AAEjB,QAAM,QAAQ,CAAC,OAAO,WAAW,YAAY,UAAU,aAAa;AACnE,QAAI,UAAU;AAEd;AAAM,iBAAW,QAAQ,OAAO;AAC/B,cAAM,eAAe,KAAK,WAAW,OAAO;AAE5C,mBAAW,QAAQ,gBAAgB,QAAQ,MAAM,SAAS,MAAM,QAAQ,CAAC,MAAM,QAAQ;AACtF,cAAI,YAAa,UAAS,YAAY,SAAS,WAAW;AACzD,kBAAM,OAAO,SAAS,MAAM,MAAM;AAElC,gBAAI,SAAS,MAAM;AAClB,yBAAW,OAAO,SAAS,YAAY,OAAO,MAAM,MAAM,WAAW,YAAY,MAAM,QAAQ,QAAQ,OAAO,KAAK;AAEnH;AAAA;AAAA;AAIF,gBAAM,eAAe,OAAO,SAAS,YAAY,QAAQ,KAAK,aAAa;AAE3E,cAAI,cAAc;AACjB,gBAAI,KAAK,IAAI,YAAY;AACxB,mBAAK,OAAO;AAEZ,yBAAW;AAAA;AAGZ,kBAAM,WAAW,OAAO;AAExB,kBAAM,gBAAgB,eAAe,YAAY,UAAU,SAAS,qBAAqB,WAAW,KAAK,MAAM,UAAU,KAAK,MAAM;AAEpI,uBAAW,MAAM,MAAM,eAAe,eAAe,WAAW,OAAO,YAAY;AAEnF,gBAAI,KAAK,IAAI,WAAW;AACvB,mBAAK,OAAO;AACZ,yBAAW;AAAA;AAGZ,gBAAI,KAAK,IAAI,gBAAgB;AAC5B,mBAAK,OAAO;AACZ,yBAAW;AAAA;AAAA,iBAEN;AACN,qBAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,EAAE,GAAG;AAC3C,kBAAI,CAAC,KAAK,IAAI,WAAW,KAAK;AAC7B,qBAAK,IAAI,WAAW;AAEpB,2BAAW,WAAW,KAAK;AAAA;AAAA;AAI7B,gBAAI,UAAU,UAAU,CAAC,KAAK,IAAI,YAAY;AAC7C,mBAAK,IAAI;AAET,yBAAW,YAAY;AAAA;AAGxB,uBAAY,gBAAe,OAAO,MAAM,YAAY,QAAQ,OAAO,OAAO,QAAQ;AAAA;AAAA;AAAA;AAKrF,WAAO;AAAA;AAGR,SAAO,MAAM,OAAO,IAAI;AAAA;",
  "names": []
}
